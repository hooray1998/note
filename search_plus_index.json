{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"algorithm/常用算法/动态规划.html":{"url":"algorithm/常用算法/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 最长公共子序列 例如: str1 = \"zxyxyz\" str2 = \"xyzyzx\" 最长公共子序列为\"xyyz\" 推导式： 如果i和j都大于0，那么 若ai = bj, L[i,j] = L[i-1,j-1] + 1 若ai != bj, L[i,j] = max(L[i-1,j], L[i,j-1]) str1 = 'zxyxyz' str2 = 'xyzyzx' L = [] for i in range(len(str1)+1): L.append([0]*(len(str2)+1)) for i,c1 in enumerate(str1): # i和j都是从0开始的，！！！ for j,c2 in enumerate(str2): if c1==c2: L[i+1][j+1] = L[i][j] + 1 else: L[i+1][j+1] = max(L[i+1][j],L[i][j+1]) print(L) 最大相邻数字和 解题思路： 遍历每个数字，把这个数字作为序列的最后一个,不能不要 变量sum大于0的时候会一直累加，小于零时置零（丢弃前面所有的数字) n = [-3,1,4,-5,-1,5,7,-11,3,4,-5,3] # n = [-3,-1,-4,-5,-1,-5,-7,-11,-3,-4,-5,-3] # 即使全为负数也ok l = [] sum = 0 for v in n: sum += v l.append(sum) if sum 零钱找零 问题描述 需要找66元的零钱，共有1,2,5,10这几个面额，最少需要几张钞票 思路 k元找零 等效于 k-1,k-2,k-5,k-10找零里面最小的 再加一 money = [1,2,5,10] target = 66 l = [] for i in range(target+1): l.append(target) l[0] = 0 for k in range(1,target+1): min = target for m in money: if ml[k-m]: min = l[k-m] else: break l[k] = min + 1 print(l[target]) 平方和最小 12 = 4+4+4 ==>3个数 13 = 9+4 ==>2个数 思路和上题一致 from math import * target = 99 money = [ x**2 for x in range(int(sqrt(target)) + 1) ] print(money) l = [] for i in range(target+1): l.append(target) l[0] = 0 for k in range(1,target+1): min = target for m in money: if ml[k-m]: min = l[k-m] else: break l[k] = min + 1 print(l[target]) 零钱组合问题 用1,2,5,20,100组成200元，共有多少种组合方式 解法 用1,2,5组成12的方式数量 等于 下面两项之和。 1,2组成12的数量 (不用5的数量) 1,2,5组成7的数量(用5的数量,至少一个) (若用一个5相当于组成7不用5) (若用两个5相当于组成7用一个5) ....... 上述所有项相加就是组成7所有的可能 money = [1,2,5,10] l = [] for i in range(11): l.append(0) l[0] = 1 for m in money: for i in range(1,11): if m 最长递增序列 问题 例如 -3,1,-2,4,5,-6 ===> -3,-2,4,5 (4个) 思路 外循环下标是i,循环下标是j, j=1->i , 若[j]sum[i],则更新sum[i] 跳楼问题 问题 某幢大楼有100层。你手里有两颗一模一样的玻璃珠。当你拿着玻璃珠在某一层往下扔的时候，一定会有两个结果，玻璃珠碎了或者没碎。这幢大楼有个临界楼层。低于它的楼层，往下扔玻璃珠，玻璃珠不会碎，等于或高于它的楼层，扔下玻璃珠，玻璃珠一定会碎。玻璃珠碎了就不能再扔。现在让你设计一种方式，使得在该方式下，最坏的情况扔的次数比其他任何方式最坏的次数都少。也就是设计一种最有效的方式。 例如：有这样一种方式，第一次选择在60层扔，若碎了，说明临界点在60层及以下楼层，这时只有一颗珠子，剩下的只能是从第一层，一层一层往上实验，最坏的情况，要实验59次，加上之前的第一次，一共60次。若没碎，则只要从61层往上试即可，最多只要试40次，加上之前一共需41次。两种情况取最多的那种。故这种方式最坏的情况要试60次。仔细分析一下。如果不碎，我还有两颗珠子，第二颗珠子会从N+1层开始试吗？很显然不会，此时大楼还剩100-N层，问题就转化为100-N的问题了。 那该如何设计方式呢？ 根据题意很容易写出状态转移方程：N层楼如果从n层投下玻璃珠，最坏的尝试次数是: max(n, 1 + F(N-n)) eg: N=100,n=60 那么所有层投下的最坏尝试次数的最小值即为问题的解 F(N) = min( max(1, 1 + F(N-1)), max(2, 1 + F(N-2)), max(3, 1 + F(N-3)) .... max(n-1, 1 + F(1)) ) 其中F(1)=1 target = 100 f = [] for i in range(target+1): f.append(0) f[1] = 1 for n in range(2,target+1): min = target for nn in range(1,n): max = f[n-nn] + 1 if max 背包问题 weight = [0,3,5,7,8,9] value = [0,4,6,7,9,10] maxWeight = 22 # 遍历体积和允许商品数量 a = [] for i in range(23): a.append([0,0,0,0,0,0]) for b in range(1,23): for w in range(1,6): a[b][w] = a[b][w-1] if weight[w] N×N方格的走法问题 dp[i][j] = dp[i][j-1] + dp[i-1][j]; C++代码实现 #include #include using namespace std; int main() { int n; while (cin >> n) { vector> dp(n+1, vector(n+1, 1)); //此用法值得学习 for (int i = 1; i 爬楼梯问题 若只允许一次1步，2步，3步三种走法 n层楼梯的走法等于[n-1] + [n-2] + [n-3] stairs = 4 a = [0] * (stairs+1) a[1] = 1 a[2] = 2 a[3] = 4 for i in range(4,stairs+1): a[i] = a[i-1] + a[i-2] + a[i-3] print(a[stairs], ' ways') 最大子数乘积 例如：input 10 output 36 for 10=3+3+4 , 36=334 思路 f[n] = max( 1f[n-1], 2f[n-2], 3f[n-3]... (n-1)f[1] ) target = 20 l = [x for x in range(target+1)] for i in range(3,target+1): max = l[i] for ii in range(1,i): if l[ii]*l[i-ii] > max: max = l[ii]*l[i-ii] l[i] = max print(l[target]) "},"algorithm/常用算法/分治算法.html":{"url":"algorithm/常用算法/分治算法.html","title":"分治算法","keywords":"","body":"分治算法 获取最大最小值 二分搜索 合并排序 第k小元素 快排 大整数乘法 分治范式 "},"algorithm/常用算法/归纳法.html":{"url":"algorithm/常用算法/归纳法.html","title":"归纳法","keywords":"","body":"归纳法 全排列 # -*- coding:utf-8 -*- '''输出abcd的全排列''' def p(m): if m==n: print(l) else: for i in range(m,n): l[i],l[m] = l[m],l[i] p(m+1) l[i],l[m] = l[m],l[i] l=['a','b','c','d'] n=4 p(0) 寻找多数元素 def findMost(m): \"\"\" 从m处开始找多数元素 \"\"\" k=1;c=l[m];j=m while j0: j+=1 if l[j]==c: k+=1 else: k-=1 if j==n: return c else: return findMost(j+1) l = [1,2,3,3,3,3,3,1,2,2] n = len(l)-1 c = findMost(0) count = 0 for cc in l: if cc == c: count += 1 if count>(n-1)/2: print(c) else: print(\"none\") "},"algorithm/常用算法/回溯法.html":{"url":"algorithm/常用算法/回溯法.html","title":"回溯法","keywords":"","body":"回溯法 算法框架 非递归int a[n], i;初始化数组a[]; i = 1; while (i > 0(有路可走) and(未达到目标)) // 还未回溯到头 { if (i > n) // 搜索到叶结点 { 搜索到一个解，输出； } else // 处理第i个元素 { a[i]第一个可能的值； while (a[i]在不满足约束条件且在搜索空间内) { a[i]下一个可能的值； } if (a[i]在搜索空间内) { : 标识占用的资源；20 : i = i + 1; // 扩展下一个结点 21: } 22: else 23: { 清理所占的状态空间； // 回溯25: i = i –1; } } } 递归 回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下 int a[n]; try(int i) { if(i>n) 输出结果; else { for(j = 下界; j 三着色问题 一个无向图，邻接矩阵存储，输出所有可能的三着色结果 递归 ```python def color(level): for i in range(1,4): c[level] = i if ok(c): print(c) else: color(level+1) a = [[0,1,1,0], [1,0,1,1], [1,1,0,1], [0,1,1,0]] c = [0,0,0,0] k = 1 flag = False color(0) 2. 非递归 ```python def ok(level): l = list() for i in c: if i!=0 and i in l: return 0 elif i!=0 and i not in l: l.append(i) else: return 1 return 6 a = [[0,1,1,0], [1,0,1,1], [1,1,0,1], [0,1,1,0]] c = [0,0,0,0,0] # 1,2,3有效 k = 1 flag = False while k>=1: while c[k]全排列 # -*- coding:utf-8 -*- ''' 全排列问题 回溯法 ''' Count = 0 # 记录迭代的次数 MaxDeep = 3 List = [0] * (MaxDeep+1) def Try(CurDeep): '''探索第CurDeep层''' global Count for i in range(List[CurDeep]+1, MaxDeep+1): Count += 1 List[CurDeep] = i if OK(CurDeep): #前面符合条件=>继续深一层Try if CurDeep == MaxDeep: print(List[1:]) break Try(CurDeep+1) List[CurDeep] = 0 def OK(CurDeep): s = set(List[1:CurDeep+1]) if len(s) == CurDeep: return True else: return False if __name__ == \"__main__\": Try(1) print(\"Count:\",Count) 素数环问题 链接 解法 注意正序反序都一样，平移以后也一样 锁定第一个恒为1即可锁定 TODO :需要优化 # -*- coding:utf-8 -*- ''' 素数环问题 回溯 ''' Count = 0 # 记录迭代的次数 MaxDeep = 8 List = [0] * (MaxDeep + 1) AllPrimeNumber = [x for x in range(3, 2 * MaxDeep, 2)] # 存储所有的素数 def Try(CurDeep): '''探索第CurDeep层''' global Count start = 2 - CurDeep%2 # 前后一定一奇一偶,第一个已锁定为1，后续奇偶确定 for i in range(start, MaxDeep + 1, 2): # 恒为奇数或偶数 Count += 1 List[CurDeep] = i if OK(CurDeep) == 1: #前面符合条件=>继续深一层Try if CurDeep == MaxDeep: print(List[1:-1]) break Try(CurDeep + 1) def OK(CurDeep): if List[CurDeep] in List[1:CurDeep]: # 当前的值不能和之前的重复 return False # 这个判断力度最大，有效减少不必要的判断 for i in range(1, CurDeep): if List[i] + List[i + 1] not in AllPrimeNumber: return False if CurDeep == MaxDeep: # 如果是最后一层，还要判断和第一个元素是否满足 if List[CurDeep] + List[1] not in AllPrimeNumber: return False return True if __name__ == \"__main__\": for i in range(1, MaxDeep * 2, 2): # 将不是素数的奇数删除 for ii in range(2, int(1 + i / 2)): if i % ii == 0: AllPrimeNumber.remove(i) break List[1] = 1 Try(2) # 第一个锁定，从第二个开始 print(\"Count:\", Count) 组合问题 # -*- coding:utf-8 -*- ''' 组合问题 , 相比全排列，三处改动 回溯法 ''' Count = 0 # 记录迭代的次数 MaxDeep = 3 MaxValue = 4 List = [0] * (MaxDeep+1) def Try(CurDeep): '''探索第CurDeep层''' global Count # 相比全排列，两处改动 # for i in range(List[CurDeep]+1, MaxDeep+1): #全排列 for i in range(List[CurDeep-1]+1, MaxValue+1): Count += 1 List[CurDeep] = i if OK(CurDeep): #前面符合条件=>继续深一层Try if CurDeep == MaxDeep: print(List[1:]) # break # 全排列 continue Try(CurDeep+1) # 没到最后一层 List[CurDeep] = 0 def OK(CurDeep): s = set(List[1:CurDeep+1]) if len(s) == CurDeep: return True else: return False if __name__ == \"__main__\": Try(1) print(\"Count:\",Count) 二维平面上的回溯法 leetcode79. 单词搜索 leetcode 200. 岛屿的个数 floodfill算法，一类经典问题 N皇后 "},"algorithm/常用算法/数据结构.html":{"url":"algorithm/常用算法/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 多项式相加，用有序链表合并的方法 表达式求职，两个栈实现 "},"algorithm/常用算法/贪心算法.html":{"url":"algorithm/常用算法/贪心算法.html","title":"贪心算法","keywords":"","body":"贪心算法 贪心策略一旦经过证明成立后，它就是一种高效的算法。 可惜的是，它需要证明后才能真正运用到题目的算法中。 一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。 求最小生成树的Prim算法和Kruskal算法都是漂亮的贪心算法。 贪心法的应用算法有Dijkstra的单源最短路径和Chvatal的贪心集合覆盖启发式 找零钱(有可能不是最优) 用的零钱尽可能少 target = 666 3张100的，10张50的，7张5元的，44张2元，99张1元 解法 先用最大面额的 活动选择 某天要安排n个活动，要求安排的活动尽可能多 第k个活动的开始时间和结束时间分别是s[k],f[k] 解法 按照结束时间排序 每次安排最先结束的活动 最小生成树 prim int minimum(CloseDge &c,int num) { int k=num,i; VRType min; for(i=0;i 拓扑排序 void FindInDegree(ALGraph G) { for(int i=0;inextarc) { indegree[i]++; } } } stackS; Status TopologicalSort(ALGraph G) { FindInDegree(G); int i,k,count; ArcNode* p; for(i=0;inextarc) { k = p->adjvex; if(!(--indegree[k])) S.push(k); } } if(count 关键路径 Status CriticalPath(ALGraph G) { if(!TopologicalOrder(G)) return -1; for(int i=0;inextarc) { k=p->adjvex; dut = *(p->inof); if(vl[k]-dut \"; } } cout 最短路径Dijkstra '''计算最短路径，采用邻接矩阵存储 若使用邻接表存储，然后使用最小堆存储未结束的点，会使find min distance更快，复杂度降为mlog(n) ''' DIS = [ [0, 3, 10, 2], [3, 0, 6, 1], [10, 6, 0, 9], [2, 1, 9, 0]] print(DIS) MIN_DIS = {} for i in range(4): MIN_DIS[i] = DIS[i][0] MIN_DIS.pop(0) for i in range(len(DIS) - 1): cur_min = min(MIN_DIS.values()) # 找到当前剩下的最近的距离 for key in MIN_DIS: if MIN_DIS[key] == cur_min: # 找到对应的下标 MIN_DIS.pop(key) # 删除这个最小边的点 print(key, cur_min) for least_dot in MIN_DIS: # 更新距离 if MIN_DIS[least_dot] > (DIS[key][least_dot] + cur_min): MIN_DIS[least_dot] = (DIS[key][least_dot] + cur_min) break Huffman编码 字符编码部分 ```cpp //从叶子结点开始逆向求每个字符的Huffman编码 HC = (HuffmanCode)malloc((n+1)sizeof(char));//分配n个字符编码的头指针向量 char cd = (char )malloc(n*sizeof(char)); //存储01编码 cd[n-1] = '\\0'; int start; for(i=1;i)malloc((n-start)sizeof(char)); strcpy(HC[i],&cd[start]); } free(cd); ``` "},"algorithm/Summary/summary_NP-hard.html":{"url":"algorithm/Summary/summary_NP-hard.html","title":"summary-NP-hard","keywords":"","body":"NP-hard 编辑 其中，NP是指非确定性多项式（non-deterministic polynomial，缩写NP）。所谓的非确定性是指，可用一定数量的运算去解决多项式时间内可解决的问题。 例如，著名的推销员旅行问题（Travel Saleman Problem or TSP）：假设一个推销员需要从香港出发，经过广州，北京，上海，…，等 n 个城市， 最后返回香港。 任意两个城市之间都有飞机直达，但票价不等。假设公司只给报销 C 元钱，问是否存在一个行程安排，使得他能遍历所有城市，而且总的路费小于 C？ 推销员旅行问题显然是 NP 的。因为如果你任意给出一个行程安排，可以很容易算出旅行总开销。但是，要想知道一条总路费小于 C 的行程是否存在，在最坏情况下，必须检查所有可能的旅行安排！ 这将是个天文数字。 旅行推销员问题是数图论中最著名的问题之一，即“已给一个n个点的完全图，每条边都有一个长度，求总长度最短的经过每个顶点正好一次的封闭回路”。Edmonds，Cook和Karp等人发现，这批难题有一个值得注意的性质，对其中一个问题存在有效算法时，每个问题都会有有效算法。 迄今为止，这类问题中没有一个找到有效算法。倾向于接受NP完全问题（NP-Complete或NPC）和NP难题（NP-Hard或NPH）不存在有效算法这一猜想，认为这类问题的大型实例不能用精确算法求解，必须寻求这类问题的有效的近似算法。 此类问题中，经典的还有 子集和问题； Hamilton回路问题；最大团问题 算法中的P问题、NP问题、NP完全问题和NP难问题 在讨论算法的时候，常常会说到这个问题的求解是个P类问题，或者是NP难问题等等，于是我特地搜了这方面的资料，自己总结了下，估计研究算法的大家应该都知道，要是我总结的哪里不对，欢迎一起探讨~ 在讲P类问题之前先介绍两个个概念：多项式，时间复杂度。(知道这两概念的可以自动跳过这部分) 1、多项式：axn-bxn-1+c 恩....就是长这个样子的，叫x最高次为n的多项式.... 咳咳，别嫌我啰嗦。。有些人说不定还真忘了啥是多项式了。。例如第一次看到的鄙人→_→ 2、时间复杂度 我们知道在计算机算法求解问题当中，经常用时间复杂度和空间复杂度来表示一个算法的运行效率。空间复杂度表示一个算法在计算过程当中要占用的内存空间大小，这里暂不讨论。时间复杂度则表示这个算法运行得到想要的解所需的计算工作量，他探讨的是当输入值接近无穷时，算法所需工作量的变化快慢程度。 举个例子：冒泡排序。 在计算机当中，排序问题是最基础的，将输入按照大小或其他规则排好序，有利于后期运用数据进行其他运算。冒泡排序就是其中的一种排序算法。假设手上现在有n个无序的数，利用冒泡排序对其进行排序， ①首先比较第1个数和第2个数，如果后者>前者，就对调他们的位置，否则不变 ②接着比较第2个数和第3个数，如果后者>前者，就对调他们的位置，否则不变 ③一直向下比较直到第n-1和第n个数比较完，第一轮结束。（这时候最大的数移动到了第n个数的位置） ④重复前三步，但是只比较到第n-1个数（将第二大的数移动到第n-1个数位置） ⑤持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 举个实例：5,4,3,2,1，对其进行排序，先是比较5跟4变成4,5,3,2,1，第一轮结束后变成43215，可以计算，当对其排序完正好要经过4+3+2+1=10次比较，当然这是最复杂的情况，即完全反序。可以知道对于n个数，至多要经过1+2+...+n-1即(n^2-n)/2次比较才能排好序。这个式子里n的最高次阶是2，可知道当n→∞时，一次性对其比较次数影响很小，所以我们把这个算法的时间复杂度比作：o(n^2)。取其最高次，可以看出，这是一个时间复杂度为多项式的表示方式。 时间复杂度排序o(1)2,n表示输入的数据个数，o(1)为常数级别） 好了，介绍完上面的概念就可以开始讲关于什么叫P类问题了。以上个例子冒泡排序为例，我们知道了，在排序这个大问题里，是可以找到一种时间复杂度为多项式o(n^2)的算法(如冒泡排序法)来求解排序问题的，所以我们说排序问题是一个有多项式时间算法的问题。 所以我们称， P类问题：存在多项式时间算法的问题。(P：polynominal，多项式) 然后扯个题外话，为什么我们要研究这个？因为计算机处理的输入常常不是那么几十个几千个那么一点点，想象一下，当计算机处理的数据达到100万个的时候，时间复杂度为o(n^2)和o(e^n)的算法，所需的运行次数简直是天壤之别，o(e^n)指数级的可能运行好几天都没法完成任务，所以我们才要研究一个问题是否存在多项式时间算法。而我们也只在乎一个问题是否存在多项式算法，因为一个时间复杂度比多项式算法还要复杂的算法研究起来是没有任何实际意义的。 好了，接下来我们介绍NP，先给定义， NP类问题：能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynominal，非确定性多项式) P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内验证他。 注意定义，这里是验证。NP类问题，我用个人的俗话理解就是，不知道这个问题是不是存在多项式时间内的算法，所以叫non-deterministic非确定性，但是我们可以在多项式时间内验证并得出这个问题的一个正确解。举个例子， 著名的NP类问题：旅行家推销问题(TSP)。即有一个推销员，要到n个城市推销商品，他要找出一个包含所有n个城市的环路，这个环路路径小于a。我们知道这个问题如果单纯的用枚举法来列举的话会有(n-1)! 种，已经不是多项式时间的算法了，(注：阶乘算法比多项式的复杂)。那怎么办呢？我们可以用猜的，假设我人品好，猜几次就猜中了一条小于长度a的路径，我画画画画，好的，我得到了一条路径小于a的环路，问题解决了，皆大欢喜。可是，我不可能每次都猜的那么准，也许我要猜完所有种呢？所以我们说，这是一个NP类问题。也就是，我们能在多项式的时间内验证并得出问题的正确解，可是我们却不知道该问题是否存在一个多项式时间的算法，每次都能解决他(注意，这里是不知道，不是不存在)。 所以这就引出了这类讨论的一个千年问题：是否 NP类问题=P类问题？ 即，是否所有能在多项式时间内验证得出正确解的问题，都是具有多项式时间算法的问题呢？ 太让人震惊了，要是解决了这个问题，那岂不是所有的NP问题都可以通过计算机来解决？ 圣战的结果是，有的存在，有的不存在。=_= 在这场圣战中，人们还发现了很多的东东，也就是我们接下来要介绍的NPC问题(啊喂，我不是游戏NPC)和NPH问题。 (PS :网络上经常有人说，这不是个NP问题吗，其实很多时候他们说的应该是NPC问题，而不是NP问题) 为了证明这个千古难题，科学家想出了很多办法。其中之一就是问题的约化。所谓问题约化就是，可以用问题B的算法来解决A ，我们就说问题A可以约化成问题B。举个例子，一元一次方程的求解，跟二元一次方程的求解，我们知道，只要能求解二元一次方程，那就可以用二元一次方程的解法来求解一元一次方程，只需要将一元一次方程加上y，并附加一个方程y=0就可以将一元一次方程变形为一个二元一次方程，然后用二元一次方程的解法来求解这个方程。注意，这里二元一次方程的解法会比一元一次的复杂。所以我们说，只需要找到解二元一次方程的规则性解法，那就能用这个规则性解法来求解一元一次方程。从这里也可以看出，约化是具有传递性的，如A约化到B，B约化到C，A就可以约化到C，同时不断约化下去，我们会发现一个很惊人的特性，就是他一定会存在一个最大的问题，而我们只需要解决了这个问题，那其下的所有问题也就解决啦！这就是我们所说的NPC问题的概念！！！ 引到NP问题里就是，对于同一类的所有的NP类问题，若他们都可以在多项式时间内约化成最难的一个NP类问题，（我们直观的认为，被约化成的问题应具有比前一个问题更复杂的时间复杂度）当我们针对这个时间复杂度最高的超级NP问题要是能找到他的多项式时间算法的话，那就等于变向的证明了其下的所有问题都是存在多项式算法的，即NP=P！！！！给出NPC问题定义， NPC问题:如果所有np问题都能在多项式时间内转化为他，则称该np问题为npc问题(NPC:NP complete又叫NP完全问题) NPC问题是NP问题的子集。 当然，很多时候NPC问题是找不到一个多项式时间算法的，更多时候他是一个指数级的算法。 最后介绍下NPH问题。 NPH问题：我们又叫NP难问题，他不是一个NP问题，然后所有的NPC问题都可以在多项式时间内转化为他的话，我们就叫他NPH（hard）问题。 "},"algorithm/Summary/summary_二叉树遍历.html":{"url":"algorithm/Summary/summary_二叉树遍历.html","title":"summary二叉树遍历","keywords":"","body":"二叉树遍历 //先序遍历T Status PreOrderTraverse(BiTree T,Status(*Visit)(TElemType e) ) { if(T) { if(Visit(T->data)) if(PreOrderTraverse(T->lchild,Visit)) if(PreOrderTraverse(T->rchild,Visit)) return 1; return 0; } return 1; } //中序遍历T Status InOrderTraverse(BiTree T,Status(*Visit)(TElemType e) ) { if(T) { if(InOrderTraverse(T->lchild,Visit)) if(Visit(T->data)) if(InOrderTraverse(T->rchild,Visit)) return 1; return 0; } return 1; } // ////后序遍历T Status PostOrderTraverse(BiTree T,Status(*Visit)(TElemType e) ) { if(T) { if(PostOrderTraverse(T->lchild,Visit)) if(PostOrderTraverse(T->rchild,Visit)) if(Visit(T->data)) return 1; return 0; } return 1; } // 非递归遍历 ////层序遍历T Status LeverOrderTraverse(BiTree T,Status(*Visit)(TElemType e)) { if(!T) return 0; queue Q; BiTree p = NULL; Q.push(T); while(!Q.empty()) { p = Q.front(); Q.pop(); if(!Visit(p->data)) return 0; if(p->lchild) Q.push(p->lchild); if(p->rchild) Q.push(p->rchild); } } //先序遍历--非递归 int PreOrderTraverse2(BiTree T,int (*visit)(TElemType e)) { stack S; BiTree p = T; while(p || !S.empty()) { if(p) { if(!visit(p->data)) return 0; //错误返回 S.push(p->rchild); p=p->lchild; } else { p = S.top(); S.pop(); } } return 1; //正常返回 } //中序遍历--非递归 int InOrderTraverse2(BiTree T,int (*visit)(TElemType e)) { stack S; BiTree p = T; while(p || !S.empty()) { if(p) { S.push(p); p=p->lchild; } else { p = S.top(); S.pop(); if(!visit(p->data)) return 0; //错误返回 p=p->rchild; } } return 1; //正常返回 } int PostOrderTraverse2(BiTree T,int (*Visit)(TElemType e)) { BiTree last = NULL; BiTree p = T; stack S; while(p||!S.empty()) { while(p) { S.push(p); p = p->lchild; } p = S.top(); if(p->rchild&&p->rchild!=last) p = p->rchild; else { if(!Visit(p->data)) return 0; S.pop(); last = p; p = NULL;//为了下一次的循环 ,因为p的左子树已经遍历过了. } } return 1; "},"algorithm/Summary/summary_排列组合.html":{"url":"algorithm/Summary/summary_排列组合.html","title":"summary排列组合","keywords":"","body":"排列 分类 排列 每个元素只有一个，全都要上场(全排列) 组合 每个元素只有一个，不用全都上场(组合数) 每个元素有多个, 组合成固定的数额 不看序列，只看各元素用了几个 总个数最少(找零钱) 求可行组合的种类数(零钱组合) 看序列(爬楼梯) 全排列 ''' 输出abcd的全排列,归纳法 输出不是字典序，需要sort ''' def p(m): if m==n: res.append(list(l)) else: for i in range(m,n): l[i],l[m] = l[m],l[i] p(m+1) l[i],l[m] = l[m],l[i] l=['a','b','c','d'] res = [] n=4 p(0) res = sorted(res) for i in res: print(i) ''' 连续数字的全排列,回溯法 ''' Count = 0 # 记录迭代的次数 MaxDeep = 3 List = [0] * (MaxDeep+1) def Try(CurDeep): '''探索第CurDeep层''' global Count for i in range(List[CurDeep]+1, MaxDeep+1): Count += 1 List[CurDeep] = i if OK(CurDeep): #前面符合条件=>继续深一层Try if CurDeep == MaxDeep: print(List[1:]) break Try(CurDeep+1) List[CurDeep] = 0 def OK(CurDeep): s = set(List[1:CurDeep+1]) if len(s) == CurDeep: return True else: return False Try(1) print(\"Count:\",Count) #include using namespace std; class Solution { private: string s; int len; vector res; public: vector Permutation(string str) { s = str; len = str.size(); Try(0); //Try2(); return res; } void Try(int d){ if(d==len-1) res.push_back(s); else{ Try(d+1);//原始的也要输出 for(int i=d+1;i=0&&str[j]>=str[j+1]) --j; if(jj&&str[i]res = s.Permutation(str); for(int i=0;i 组合 普通组合问题 # -*- coding:utf-8 -*- ''' 组合问题 , 相比全排列，三处改动 回溯法 ''' Count = 0 # 记录迭代的次数 MaxDeep = 3 MaxValue = 4 List = [0] * (MaxDeep+1) def Try(CurDeep): '''探索第CurDeep层''' global Count # 相比全排列，两处改动 # for i in range(List[CurDeep]+1, MaxDeep+1): #全排列 for i in range(List[CurDeep-1]+1, MaxValue+1): Count += 1 List[CurDeep] = i if OK(CurDeep): #前面符合条件=>继续深一层Try if CurDeep == MaxDeep: print(List[1:]) # break # 全排列 continue Try(CurDeep+1) # 没到最后一层 List[CurDeep] = 0 def OK(CurDeep): s = set(List[1:CurDeep+1]) if len(s) == CurDeep: return True else: return False if __name__ == \"__main__\": Try(1) print(\"Count:\",Count) 爬楼梯问题 若只允许一次1步，2步，3步三种走法 n层楼梯的走法等于[n-1] + [n-2] + [n-3] stairs = 4 a = [0] * (stairs+1) a[1] = 1 a[2] = 2 a[3] = 4 for i in range(4,stairs+1): a[i] = a[i-1] + a[i-2] + a[i-3] print(a[stairs], ' ways') 零钱组合问题 用1,2,5,20,100组成200元，共有多少种组合方式 解法 用1,2,5组成12的方式数量 等于 下面两项之和。 1,2组成12的数量 (不用5的数量) 1,2,5组成7的数量(用5的数量,至少一个) (若用一个5相当于组成7不用5) (若用两个5相当于组成7用一个5) ....... 上述所有项相加就是组成7所有的可能 money = [1,2,5,10] l = [] for i in range(11): l.append(0) l[0] = 1 for m in money: for i in range(1,11): if m 零钱找零 问题描述 需要找66元的零钱，共有1,2,5,10这几个面额，最少需要几张钞票 思路 k元找零 等效于 k-1,k-2,k-5,k-10找零里面最小的 再加一 money = [1,2,5,10] target = 66 l = [] for i in range(target+1): l.append(target) l[0] = 0 for k in range(1,target+1): min = target for m in money: if ml[k-m]: min = l[k-m] else: break l[k] = min + 1 print(l[target]) "},"algorithm/Summary/summary_排序算法.html":{"url":"algorithm/Summary/summary_排序算法.html","title":"summary排序算法","keywords":"","body":"排序算法 十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 三色排序 使用i，j记录前两个颜色的尾巴的后一个元素，k记录第三种颜色的前端的前一个 l = [x%3+1 for x in range(1,20)] i = j = 0 k = len(l)-1 count = 0 while j 6、快速排序（Quick Sort）(二路排序) 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 l = [3,5,1,4,9,2,1,2] def partition(start, end): print('start', start, 'end',end) key = l[start] while start=key: end -= 1 l[start] = l[end] while start 三路快排 三路快排是为了应对数列中有 大量的重复数据 ,为了避免对重复数据进行反复排序，将每次排列的数列分成三部分 划分原理跟三色排序差不多 随机快排 快排的平均时间复杂度O[nlog(n)]，最坏情况可能会达到O[n^2]。由于快排对应于乱序的数列排序速度较快，而越接近排好序的数列则排序速度越慢。为了解决这个问题，我们有时需要将数组打乱提高数列的混乱度，有助于提高排序速度。 7、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1] ''' 大顶堆 升序''' import random l = [ random.randint(1,100) for i in range(33)] def HeapAdjust(s, m): k = s * 2 while k l[k]: # 挑出大儿子 k = k+1 if l[k] 8、计数排序（Counting Sort） 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 9、桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 9.4 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort） 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.4 算法分析 基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。 1、冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 2、选择排序（Selection Sort） 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 3、插入排序（Insertion Sort） 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 4、希尔排序（Shell Sort） 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 5、归并排序（Merge Sort） 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 ''' 合并排序 ''' import random l = [ random.randint(1,100) for i in range(33)] def MergeSort(s, e): if s != e: m = int((e+s)/2) MergeSort(s, m) MergeSort(m+1, e) MergeList(s, m, e) def MergeList(s, m, e): newl = [] i, j = s, m+1 while i "},"algorithm/Summary/summary_树总结.html":{"url":"algorithm/Summary/summary_树总结.html","title":"summary树总结","keywords":"","body":"树 定义 树是一种非线性的数据结构 树是若干个结点的集合(个数>=0),是由唯一的根和若干棵互不相交的子树组成 树的结点树可以为0，对于这种树，我们称为空树 树与图的区别在于树中没有一个闭环 基本术语 结点：组成树的元素，结点包含数据元素和指向子树的分支 结点的度：结点分支数 树的度：结点拥有的最大分支数 叶子结点：度为0的结点 二叉树 定义：即每个结点都最多只有两个子结点的树 完全二叉树 高度为h的二叉树，其1~h-1层为满结点，且其h层（叶子结点层）的节点从左至右依次排列（最多2^h-1个，最少1个） 满二叉树 除最后一层外，每个结点都有左右子结点的二叉树 平衡二叉树 任一结点的左右子树的高度差绝对值不超过1，且左右子树均为平衡二叉树（防止树退化成链表） 二叉排序树（二叉查找树） 左小右大，子树也是二叉查找树 删除与插入操作 平衡二叉树 左右子树的深度之差绝对值不超过1；子树都是平衡二叉树 B树 概念： 1. B树每个节点有K（K>0）个关键字（根节点除外，根节点没有关键字时树为空），结点的分支数等于关键字数+1，最大的分支数就是B树的阶数，因此m阶的B树中结点最多有m个分支 非根节点和叶子节点的其他节点，分支数 > (阶数 / 2)，若5阶B树则非叶子节点分支数至少为3 结点内各关键字互不相等且按从小到大排列，下层节点内的关键字取值总是落在由上层节点关键字所划分的区间内 对于一个m阶B树，关键字个数范围 ceil(m/2) - 1 ~ m -1 (5阶 则是 2 ~ 4) 删除与插入操作 B+Tree B+树是B树的升级版本,就目前情况，绝大部分都已经用B+树代替了B树了，文件管理、索引等等，当然，具体为什么可以看下面的优点介绍 区别：B+树非叶子节点不存储数据，每个叶子节点指向相邻的叶子节点 查找插入删除与B树类似 但 B+树提供了旋转功能，来尽可能的减少页的拆分 旋转发生在leaf Page已经满了、但是其左右兄弟节点没有满的情况下 B树与B+树的比较 B树中关键字集合分布在整棵树中，叶节点中不包含任何关键字信息，而B+树关键字集合分布在叶子结点中，非叶节点只是叶子结点中关键字的索引； B树中任何一个关键字只出现在一个结点中，而B+树中的关键字必须出现在叶节点中，也可能在非叶结点中重复出现； 原文：https://blog.csdn.net/qq_34694342/article/details/84255739 "},"algorithm/Summary/summary_算法的优化.html":{"url":"algorithm/Summary/summary_算法的优化.html","title":"summary算法的优化","keywords":"","body":"优化算法 先用划分力度最大的特征 比如想找一个有头发的中年男人 如果按照 有头发-> 中年 -> 男人 这个序列找的话，会多比较很多次 如果先按照男女划分，就会省掉很多比较 "},"algorithm/Summary/summary_异或的应用.html":{"url":"algorithm/Summary/summary_异或的应用.html","title":"summary异或的应用","keywords":"","body":"异或在算法中的应用 抑或重要性质: a^b^a = a 同时满足交换律，结合律 交换两个数 a, b = 3, 4 print('{:0>4b}'.format(a)) # 输出二进制 print('{:0>4b}'.format(b)) a = a^b # a = 0111 b = b^a # b^(a^b) => a # b = 0011 a = a^b # (a^b)^a => b # a = 0100 python中更简单的实现 a, b = b, a ### 找出唯一的落单数 ''' 用reduce函数简化 ''' from functools import reduce # 引入reduce函数 l1 = [1, 2, 3, 4, 5, 2, 4, 5, 1] print(reduce(lambda x, y: x^y, l1, 0)) # 相邻依次异或，初始值从0开始，避免列表长度为1 # output 3 ''' 迭代实现 ''' xor = 0 for i in l1: xor ^= i print(xor) 找出仅有的两个落单数 from functools import reduce l = [1, 6, 2, 3, 4, 5, 4, 5, 6, 1] xor = reduce(lambda x, y: x^y, l, 0) xor_bin_str = '{:0>32b}'.format(xor) # 32位数最大支持几百万 index = (32-1) - xor_bin_str.rfind('1') # 从右往左找第一个1(因为两数不等，必有1) l1 = [ i for i in l if (i>>index)%2 == 1 ] # 第index位为1的那组 l2 = [ i for i in l if (i>>index)%2 == 0 ] # 第index位为0的那组 print(reduce(lambda x, y: x^y, l1, 0)) print(reduce(lambda x, y: x^y, l2, 0)) "},"algorithm/Summary/summary_找零钱问题.html":{"url":"algorithm/Summary/summary_找零钱问题.html","title":"summary找零钱问题","keywords":"","body":"找零钱问题的动态规划和贪心算法对比 动态规划算法一定是最优解，而贪心未必 如果是中国的零钱，1,2,5,10,50,100 贪心即可得到最优解 但如果序列不是1 2 5 10 ,或着类似的问题，则需要小心使用贪心算法 算法思路 动态规划: k元找零 等效于 k-1,k-2,k-5,k-10找零里面最小的 再加一 贪心算法: 优先使用较大的金额 遍历10以内的所有递增序列,分析贪心和动态规划答案相同与不相同的序列规律 money = [1,1,1] for a in range(1,9): money[0] = a for b in range(a+1,10): money[1] = b for c in range(b+1,11): money[2] = c flag = True # 记录两种算法结果是否相同 target = 1 while target l[k-m]: min = l[k-m] else: break l[k] = min + 1 # 贪心算法解法 先用最大面额的 sum = 0 c_target = target sum +=c_target//money[2] c_target %= money[2] sum +=c_target//money[1] c_target %= money[1] sum +=c_target if sum != l[target]: flag = False # print(money) #输出not equal list break target += 1 if flag: print(money) #输出equal list 结果分析 两种解法结果一致的money取值 规律：前面的数乘2不大于后面的数+1 (必要条件) m1|m2|m3 :-:|:-:|:-: 1 | 2 | 3 1 | 2 | 4 1 | 2 | 5 1 | 2 | 6 1 | 2 | 7 1 | 2 | 8 1 | 2 | 9 1 | 2 | 10 1 | 3 | 5 1 | 3 | 6 1 | 3 | 7 1 | 3 | 8 1 | 3 | 9 1 | 3 | 10 1 | 4 | 7 1 | 4 | 8 1 | 4 | 10 1 | 5 | 9 1 | 5 | 10 两种解法结果不一致 证明上述规律不是充分条件 当money = 【1 | 4 | 9】时 target=16 |动态规划:4*4. 贪心:9+4+1+1+1 m1 m2 m3 1 3 4 1 4 5 1 4 6 1 4 9 1 5 6 1 5 7 1 5 8 1 6 7 1 6 8 1 6 9 1 6 10 1 7 8 1 7 9 1 7 10 1 8 9 1 8 10 1 9 10 2 3 4 2 3 5 2 3 6 .. .. .. 省略 67 行 .. .. .. 5 7 10 5 8 9 5 8 10 5 9 10 6 7 8 6 7 9 6 7 10 6 8 9 6 8 10 6 9 10 7 8 9 7 8 10 7 9 10 8 9 10 "},"cppNotes/Cpp多态.html":{"url":"cppNotes/Cpp多态.html","title":"Cpp多态","keywords":"","body":"cpp多态 如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是虚函数，并且对基类中的版本形成覆盖。这时，通过指向子类对象的基类指针，或者引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而非基类中的原始版本，这种语法现象被称为多态。 虚函数覆盖的条件 只有类的成员函数才能被声明为虚函数，全局函数和类的静态成员函数都不能被声明为虚函数. 只有在基类中被冠以virtual关键字的成员函数才能作为虚函数被子类覆盖，而与子类中virtual关键字无关。 虚函数在子类中的覆盖版本必须和该函数在基类中原始版本拥有相同的函数签名. 多态的条件 多态特性除了需要在基类中声明虚函数，并在子类中提供有效的覆盖以外还必须通过指针或者引用来调用虚函数，才能表现出来。 纯虚函数，抽象类，纯抽象类 纯虚函数 形如virtual 返回类型 函数名 (形参表) [const] = 0;的虚函数被称为纯虚函数。纯虚函数不需要定义，表示抽象的行为。 抽象类 如果一个类包含了至少一个纯虚函数，那么这个类就是抽象类。抽象类不能被实例化为对象。 如果子类没有覆盖其抽象基类中的全部纯虚函数，那么该子类就也是一个抽象类。类的抽象属性可以被继承。 纯抽象类 如果一个抽象类中除了构造和析构函数以外所有的成员函数都是纯虚函数，那么该抽象类就是一个纯抽象类，有名接口类。 虚析构函数 delete一个指向子类对象的基类指针，实际被调用的仅仅是基类的析构函数。基类的析构函数只负责析构子类对象中的基类子对象，而不会调用子类的析构函数。这样在子类中动态分配的资源就会形成内存泄漏。 如果将基类的析构函数声明为虚函数，那么子类的析构函数就也是一个虚函数，并且对基类的虚函数构成有效的覆盖，可以表现出多态特性。这时delete一个指向子类对象的基类指针，实际被调用的将是子类的析构函数。子类的析构函数在释放子类对象特有的动态资源之后会自动调用基类的析构函数，释放基类子对象中的动态资源。最终实现完美的资源释放，避免了内存泄漏。 一般而言，如果一个类没有分配任何动态资源，可以不为其定义析构函数，但是编译器会为其提供缺省析构函数，而缺省析构函数不是虚函数。为了防止delete指向子类对象的基类指针时产生内存泄漏的风险，即使是空的析构函数也有为基类定义的必要，仅仅是为了通过虚析构在对象销毁过程中体现出多态特性。 类中哪些函数可以虚？ 函数 虚否 构造函数 不可以虚 静态成员函数 不可以虚 析构函数 可以虚 普通成员函数 可以虚 操作符函数 可以虚 "},"cppNotes/c++基础总结.html":{"url":"cppNotes/c++基础总结.html","title":"c++基础总结","keywords":"","body":"C++基础总结 *&表示对指针的引用。 类成员的初始化顺序 由于按成员在类定义中的声明顺序进行构造，而不是按构造函数说明中冒号后面的顺序 ::叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。::可以不跟类名，表示全局数据或全局函数（即非成员函数）。 如果 const 出现在 左边，则指针指向的内容为常量；如果 const 出现在 右边，则指针自身为常量；如果 const 出现在 * 两边，则两者都为常量。 effective C++上有个好记的方法：const在号左边修饰的是指针所指的内容；const在号右边修饰的是指针。 简单记就是：左内容，右指针。 const int a; int const a; const int *a; int * const a; int const * a const; 指针和自增 int a[5] = {1,2,3,4,5}; int *p = a; cout sizeof总结 参数为数据类型或者为一般变量： 例如sizeof(int),sizeof(long)等等。 参数为数组或指针：※※※※※ int a[50]; //sizeof(a)=4*50=200;求数组所占的空间大小 int *a=new int[50];// sizeof(a)=4; a为一个指针，sizeof(a)是求指针的大小,在32位系统中，当然是占4个字节。 结构体 计算结构变量的大小必须讨论数据对齐的问题。 1. 某些平台只能在特定的地址处访问特定类型的数据； 2. 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。 3. 静态变量是存放在全局数据区的，而sizeof计算栈中分配的大小，是不会计算在内的)与结构体实例的存储地址无关(注意只有在C++中结构体中才能含有静态数据成员，而C中结构体中是不允许含有静态数据成员的)。 4. 结构体的长度一定是最长的数据元素的整数倍。 另外有几点需要注意： 　　第一、结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。 　　第二、没有成员变量的结构或类(非虚)的大小为1，因为必须保证结构或类的每一个实例在内存中都有唯一的地址。 　　第三、包含虚函数的类或者虚继承的类，需要算上虚表指针的占的4个字节 new失败返回NULL const 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。 类成员函数的重载、覆盖和隐藏区别？ a.成员函数被重载的特征： （1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual 关键字可有可无。 b.覆盖是指派生类函数覆盖基类函数，特征是： （1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键字。 c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆 在运行时，能根据其类型确认调用哪个函数的能力，称为多态性，或称迟后联编，或滞后联编。编译时就能确定哪个重载函数被调用的，称为先期联编。 复制代码 多态性可可以简单的概括为“一个借口，多种方法”，在程序运行的过程中才决定调用的函数。 虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”或“重写”。 覆盖是指子类重新定义父类的虚函数的做法。 重载是指允许存在多个同名函数，而这些函数的参数表不同。 复制代码 为了指明某个成员函数具有多态性，用关键字virtual来标志其为虚函数。 如果虚函数在基类与子类中出现的仅仅是名字的相同，而参数类型不同，或返回类型不同，即使写上了virtual关键字，则也不进行迟后联编。 一个类中将所有的成员函数都尽可能地设置为虚函数总是有益的。它除了会增加一些资源开销，没有其它坏处。 设置虚函数，需注意下列事项： 只有类的成员函数才能说明为虚函数。这是因为虚函数仅适用于有继承关系的类对象，所以普通函数不能说明为虚函数。 静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。 内联函数不能是虚函数，因为内联函数是不能在运行中动态确定其位置的。即使虚函数在类的内部定义，编译时，仍将其看作非内联的。 构造函数不能是虚函数，因为构造时，对象还是一片未定型的空间。只有在构造完成后，对象才能成为一个类的名副其实的实例。 析构函数可以是虚函数，而且通常声明为虚函数 三十一、lambda表达式 一个lambda表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。与任何函数相似，一个lambda具有一个返回类型、一个参数列表、一个函数体。但与函数不同，lambda可以定义在函数内部，一个lambda表达式具有如下形式： capture list捕获列表 {函数体}，例子如下： auto f = {return a.size() 二十八、拷贝构造函数为什么传引用？ 原因：参数为引用，不为值传递是为了防止拷贝构造函数的无限递归，最终导致栈溢出。这也是编译器的强制要求。 二十九、程序崩溃原因 读取未赋值的变量 函数栈溢出 数组越界访问 指针的目标对象不可用 二十二、C/C++内存管理方式，内存分配 内存分配方式：在C++中内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区。 栈：在执行程序过程中，局部作用域出现的一些局部变量可以在栈上创建，等脱离该作用域创建的内存被释放。栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 堆：用于程序内存动态分配，用c/c++中的new/malloc分配，delete/free释放。堆则是 C/C++ 函数库提供的，它的机制是很复杂的。 自由存储区：它是C++基于new操作符的一个概念，凡是通过new操作符申请的内存即为自由存储区 全局/静态存储区：这块内存在程序编译期间已经分配好，在程序整个运行阶段一直存在。全局变量个和静态变量 常量存储区：特殊的一块内存，里面存放的是常量，不允许修改。 十九、struct内存大小的确定 存在内存对齐的缘故，对于32位机器，是4字节对齐，64位机器是8字节对齐。 十二、static 局部静态变量：static局部变量和普通局部变量有什么区别？ 生存期不同 static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值 程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 全局静态变量：static全局变量与普通的全局变量有什么区别？ 作用域不同 非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。 static全局变量只初使化一次，防止在其他文件单元中被引用;可以避免在其它源文件中引起错误。 一个C++源文件从文本到可执行文件经历的过程 预处理：对所有的define进行宏替换；处理所有的条件编译#idef等；处理#include指令；删除注释等；bao#pragma 编译：将预处理后的文件进行词法分析、语法分析、语义分析以及优化相应的汇编文件 优化: 汇编：将汇编文件转换成机器能执行的代码 链接：包括地址和空间分配，符号决议和重定位 十、malloc的原理 函数原型： void malloc(size_t n)返回值额类型为void，为动态分配得到的内存，但代大小是确定的，不允许越界使用。 malloc函数的实质 它有一个可以将可用内存块连接成一个长的列表的空闲链表 当调用链表时，它沿着连接表寻找一个大到可以满足用户请求所需内存 将内存一分为二，将分配给用户那块内存传给用户，剩下的那块返回连接表。 sizeof和strlen的区别: sizeof: 返回一个变量或者类型的字节大小,占用的空间大小，不管它第几个是\\0 strlen: 求字符串的长度，也就是从第一个字符到第一个\\0的距离 1. static（静态）变量有什么作用 个体明显的作用： 只初始化一次：在一个函数被调用的过程中其值维持不变，一直都没有被销毁，下一次的运算依据是上一次的结果值。目的是为了防止在其他文件单元中被引用。 作用域范围是有限：即如果一个变量被声明为静态的，那么该变量只可被模块内所有函数访问 static函数只在一个源文件中有效，不能被其他源文件使用。 #include void fun(int i) { static int value=i++; value++; printf(\"%d\\n\",value); } int main() { fun(0); fun(3); fun(5); return 0; } //程序输出： 1 2 3 static int value=i++这个定义语句只会在第一次调用的时候执行 在头文件中定义静态变量，是否可行？为什么？ 不可行，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。 因为如果在使用了这个头文件的每个C 语言文件中定义静态变量，按照编译的步骤，在每个头文件中都存在一个静态变量，从而会引起空间浪费和程序错误。 所以不推荐在头文件中定义任何变量，当然也包括静态变量。 2. const有哪些作用： 定义const常量，具有不可变性 保护被修饰的东西 进行类型检查 方便进行参数的调整和修改 为函数重载提供参考 节省空间，避免不必要的内存分配 提高了程序的效率。编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译器间的常量，没有了存储与读内存的操作，使得它的效率也很高。 为什么要使用const引用？ NOTE 一般引用初始化一个左值的时候，没有任何问题 而当初始化值不是一个左值时，则只能对一个常引用赋值 而且这个赋值是有一个过程的 首先将值隐式转换到类型T 然后将这个转换结果存放在一个临时对象里 最后用这个临时对象来初始化这个引用变量。 const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量 而非const引用只能绑定到该引用同类型的对象。 3. volatile在程序设计中有什么作用？ NOTE volatile 是一个修饰符，它用来修饰被不同线程访问和修改的变量。被volatile类型定义的变量，系统每次用到它的时候都是直接从对应的内存当中提取，而不会利用cache中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化。所以，volatile一般用于修饰多线程间被多个任务共享的变量和并行设备硬件寄存器等。 4.char str[]=\"abc\";char str2[]=\"abc\";str1与str2不相等，为什么？ 两者不相等，是因为str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区的首地址。 const char *str3=\"abc\"和const char *str4=\"abc\"相等 str3和str4是字符指针而非字符数组，并不分配内存，其后的“abc”存放在 *常量区，str3和str4是指向它们指向的地址的首地址，而它们自己仅是指向该区首地址的指针，所以相等。 5. C++里面是不是所有的动作都是main()函数引起的，但是一个C语言程序总是从main()函数开始执行的。 不是，对于C++程序而言， 静态变量、全局变量、全局对象的分配早在main()函数之前已经完成 所以并不是所有的动作都是main()引起的，只是编译器是由main()开始执行的，main()只不过是一个约定的函数入口，在main()函数中的显示代码之前，会调用一个由编译器生成的_main()函数，而_main()函数会进行所有全局对象的构造及初始化工作。 在main()函数退出后再执行一段代码？ 答案依然是全局对象， 当程序退出后，全局变量必须销毁，自然会调用全局对象的析构函数，所以剩下的就同构造函数一样了。 6. 前置运算和后置元素有什么区别？ 以++操作为例，对于变量a，++a表示取a的地址，增加它的内容，然后把值放在寄存器中 a++表示取a的地址，把它的值放入寄存器中，然后增加内存中a的值 前置（++）通常要比后置自增（—++）效率更高。 例题：a是变量，执行(a++)+=a语句是否合法？ 左值和右值的概念 左值就是可以出现在表达式左边的值（等号左边），可以被改变，它是存储数据值的那块内存的地址，也称为变量的地址 右值是指存储在某内存地址中的数据，也称为变量的数据。 左值可以作为右值，但是右值不可以是左值。 本题不合法 a++不能当做左值使用。++a可以当作左值使用。++a表示取a的地址，对它的内容进行加1操作，然后把值放在寄存器中。a++表示取a的地址，把它的值装入寄存器，然后对内存中a的值执行加1操作。 7. new/delete与malloc/free的区别是什么？ new能够自动计算需要分配的内存空间，而malloc需要手工计算字节数。 new和delete直接带具体类型的指针，malloc和free返回void的指针。 new是类型安全的，而malloc不是。 new一般由两步构成，分别是new操作和构造。new操作对应于malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。 new将调用构造函数，而malloc不能；delete将调用析构函数，而free不能。 malloc/free需要库函数stdlib.h的支持，而new/delete不需要 注意资源泄漏的问题 new/delete，malloc/free必须配对使用。 并且释放完内存后，应该将指针指向NULL。 因为仅仅告诉操作系统存储指针的内存已经释放了，可以做其他用途，但指针的值还没有被立刻清空 8. 已知String类定义，如何实现其函数体。 String类定义如下： class String{ public: String(const char* str=NULL); String(const String &another); ~String(); String &operator=(const String &rhs); private: char* m_data; }; String::String(const char *str) { if(str==NULL) { m_data=new char[1]; m_data[0]='\\0'; } else { m_data=new char[strlen(str)+1]; strcpy(m_data,str); } } String::String(const String &another) { m_data=new char[strlen(another.m_data)+1]; strcpy(m_data,another.m_data); } String::~String() { delete[] m_data; } String& String::operator=(const String &rhs) { if(this==&rhs) return *this; delete[] m_data; m_data=new char[strlen(rhs.m_data)+1]; strcpy(m_data,rhs.m_data); return *this; } 9. 栈空间的最大值是多少？ 在Windows，栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的 在Windows下，栈的大小是2MB。而申请堆空间的大小一般小于2GB. 栈的速度快，但是空间小，不灵活。 堆获得的空间比较灵活，也比较大，但是速度相对慢一些。 由于内存的读取速度比硬盘快，当程序遇到大规模数据的频繁存取时，开辟内存空间很有作用。栈的速度快，但是空间小，不灵活。堆是向高地址扩展的，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址的，而堆的大小受限于计算机系统中的有效虚拟内存，所以堆获得的空间比较灵活，也比较大，但是速度相对慢一些。 10. 指针和引用的区别 指针指向一块内存，它的内容是所指内存的地址，引用是某块内存的别名 从本质上讲 指针是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，即其所指向的地址可以被改变，其指向的地址中所存放的数据也可以被改变。 而引用则只是一个别名而已，它在逻辑上不是独立的，它的存在具有依赖性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的，即自始自终只能依赖于同一个变量，具有“从一而终”的特性。 作为参数传递时 指针传递参数本质上是值传递的方式，它所传递的是一个地址值（所有对形参的改变都只是这个地址值中存放变量的改变，而存放这个地址值的指针是不会变化的。如果要改变存放该地址值的指针，需要传入的是该指针的地址，所以可以使用指针的指针或者指针的引用。）。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值。 而在引用传递过程中，被调用函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。对引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。 引用使用时不需要解引用（*），而指针需要解引用。 引用只能在定义时被初始化一次，之后不能被改变，即引用具有“从一而终”的特性，而指针却是可以改变的。 引用不可以为空，而指针可以为空。引用必须与存储单元相对应，一个引用对应一个存储单元。 对引用进行sizeof操作得到的是所指向的变量（对象）的大小，而对指针进行sizeof操作得到的是指针本身（所指向的变量或对象的地址）的大小。 指针和引用的自增（++）运算意义不一样。 如果返回动态分配的对象或内存，必须使用指针，引用可能引起内存泄漏。 11. 指针和数组是否表示同一概念 主要表现在以下两方面的不同： 修改内容不同。 例如,char a[]=\"hello\",可以通过去下标的方式对其进行修改，而对于char *p=\"word\"，此时p指向常量字符串，所以p[0]='x'是不允许的。 所占字节数不同 例如，char p=\"world\",p为指针，则sizeof(p)得到的是一个指针变量的字节数，而不是p所指的内存容量。 char a[]=\"hello world\"; char \\p=a; 在32位机器上，sizeof(a)=12字节，而sizeof(p)=4字节。 但要注意的是，当数组作为函数参数进行传递时，该数组自动退化为同类型的指针。 13. 野指针？空指针？ 野指针是指指向不可用内存的指针。 任何指针变量在被创建时，不会自动成为NULL指针（空指针），其默认值是随机的，所以指针变量在创建的同时应当被初始化，或者将指针设置为NULL，或者让它指向合法的内存，而不应该放之不理，否则就会称为野指针。 指针被释放（free或delete）后，未能将其设置为NULL，也会导致该指针变为野指针。 指针操作超越了变量的作用范围。 14. #include和#include\"filename.h\"有什么区别 对于#include 编译器先从标准库路径开始搜索filename.h,然后从本地目录搜索，使得系统文件调用较快。 而对于#include\"filename.h\" 编译器先从用户的工作路径开始搜索filename.h，后去寻找系统路径，使得自定义文件较快。 15. 宏的总结 宏与函数的区别 函数调用时，首先求出实参表达式的值，然后带入形参。而使用带参数的宏只是进行简单的字符替换 函数调用在程序运行时处理的，它需要分配临时的内存单元；而宏展开则是在编译时进行的，在展开时并不分配内存单元，也不进行值的传递处理，也没有“返回值”的概念。 对函数中的实参和形参都有定义类型，两者的类型要求一致。而宏不存在类型问题，宏名无类型，它的参数也无类型，只是一个符号代表，展开时带入指定的字符即可。 调用函数只可能得到一个返回值，而用宏可以设法得到几个结果。 使用宏次数多时，宏展开后源程序会变很长，因为每展开一次都是程序内容增长，而函数调用不会使源程序变长。 宏替换不占用运行时间，而函数调用则占用运行时间 参数每次用于宏定义时，它们都要重新求值，由于多次求值，具有副作用的参数可能会产生不可预料的结果。 枚举和define有什么不同 枚举常量是实体中的一种，而宏定义不是实体 枚举常量属于常量，而宏定义不是常量 枚举常量具有类型，但宏没有类型，枚举变量具有与普遍变量相同的性质，如作用域、值等，但宏没有。 define宏常量是在预编译阶段进行简单替换，枚举常量则是在编译的时候确定其值。 一般在编译器里，可以调试枚举常量，但是不能调试宏常量 枚举可以一次定义大量相关的常量，而#define宏一次只能定义一个 typedef和define的区别 原理不同。#define是C语言中定义的语法，它是预处理指令，在预处理时进行简单的字符替换，不作正确性检查。typedef是关键字，它在编译时处理，所以typedef有类型检查的功能 功能不能。typedef用来定义类型的别名，这些类型可以是内置类型也可以是用户自定义的类型。#define不只是可以为类型去名字，还可以定义常量、变量、编译开关 作用域不同。#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域 对指针的操作不同。两者修饰指针类型时，作用不同。 宏定义与inline函数的区别 宏定义是在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码； 宏定义没有类型检查，而内联函数有类型检查。 define和const的区别 define只是用来进行单纯的文本替换，不分配内存空间，而const常量存在于程序的数据段，并在堆栈中分配了空间 const常量有数据类型，而define常量没有数据类型 很多IDE支持调试const定义的常量，而不支持define定义的常量 16. C语言中struct和union的区别是什么 union struct 公用同一个内存地址空间 不同成员会存在不同的地址。 不同成员赋值会对其他成员重写 不同成员赋值是互不影响的 C语言和C++中struct的区别 C Cpp 不能有函数成员 struct可以有 数据成员没有private、public和protected访问权限的设定 struct成员有访问权限限定。 没有继承关系的 struct有丰富的继承关系 C++中struct和class的区别 C++class C++struct 默认是private的 struct默认是public的 可以用于定义模板,就像typename struct不可以 17. 位运算总结 如何快速求取一个整数的7倍？ (X 如何实现位操作求两个数的平均值 一般而言，求平均值可以使用(x+y)>>1，但是x+y可能移除，所以不使用加入，而使用异或和与运算实现加法： (x&y)+(x^y)>>1 如何利用位运算计算数的绝对值？ 以x为负数为例来分析，因为在计算机中，数字都是以补码的形式存在的，求负数的绝对值，应该是不管符号位，执行按位求反，末尾加1操作即可。 对于一个负数，将其右移31位后会变成0xffffffff，而对于一个正数而言，右移31位则为0x00000000，而0xffffffff^x+x=-1,因为任何数与1111异或，其实质都是把x的0和1进行颠倒计算。如果用变量y表示x右移31为，则(x^y)-y则表示的是x的绝对值。 18. 考虑n个二进制组成的数中，有多少个数中不存在两个相邻的1. 当n=1时，满足条件的二进制数为0、1，一共两个数；当n=2时，满足条件的二进制数有00、01、10，一共3个数；当n=3时，满足条件的二进制数有000、001、010、100、101，一共5个数。对n位二进制数，设所求结果a(n)，对于第n位的值，分为0或者1两种情况： 第n位为0，则有a(n-1)个数。 第n位为1，则要满足没有相邻万为1的条件，第n-1位为0，有a(n-2)个数，因此得出结论a(n)=a(n-1)+a(n-2) 满足斐波拉契数列。 19. 函数指针和指针函数的区别 指针函数是指带指针的函数，本质上是一个函数，函数返回类型是某一类型的指针。其形式一般如下所示： 类型标识符 函数名(参数列表) 例如，int f(x,y)，它的意思是声明一个函数f(x,y),该函数返回类型为int型指针。 而函数指针是指向函数的指针，即本质是一个指针变量，表示的是一个指针，它指向的是一个函数。其形式一般如下所示： 类型说明符 （函数名）（参数） 例如，int (pf)(int x)它的意思就是声明一个函数指针，而pf=func则是将func函数的首地址赋值给指针。 引申： 数组指针/指针数组 数组指针就是指向数组的指针，它表示的是一个指针，它指向的是一个数组，它的重点是指针。例如，int(pa)[8]声明了一个指针，该指针指向了一个有8个int型元素的数组。数组指针类似于二维i数组。即int a[][8]; 指针数组就是指针的数组，表示的是一个数组，它包含的元素是指针，它的重点是数组。例如，int ap[8]声明了一个数组，该数组的每一个元素都是int型的指针。 函数模板/模板函数 函数模板是对一批模样相同的函数的说明描述，它不是某一具体的函数；而模板函数则是将函数模板内的“数据类型参数”具体化得到的重载函数（就是由模板而来的函数简单地说，函数模板是抽象的，而模板函数则是具体的。 函数模板减少了程序员输入代码的工作量，是C++中功能最强的特性之一，是提高软件代码重用率的重要手段之一。函数模板的形式一般如下所示： template\\ \\ \\(模板函数形参表) { 　　//函数体 } 其中\\的类型可以是任何类型。需要注意的是，函数模板并不是一个实实在在的函数，它是一组函数的描述，它并不能直接执行，需要实例化成模板函数后才能执行，而一旦数据类型形参实例化以后，就会产生一个实实在在的模板函数了。 类模板/模板类 类模板与函数模板类似，将数据类型定义为参数，描述了代码类似的部分类的集合，具体化为模板类后，可以用于生存具体的对象。 template class { 　　//类说明体 }; template ::(形参表) { 　　//成员函数定义体 } 其中与函数模板中的一样，而类模板本身不是一个真实的类，只是对类的一种描述，必须用类型参数将其实例化为模板类后，才能用来生成具体的对象。简而言之，类是对象的抽象，而类模板就是类的抽象。 C++中引入模板类主要有以下5个方面的好处： 可用来创建动态增长和减少的数据结构 它是类型无关的，因此具有很高的可复用性 它在编译时而不是运行时检查数据类型，保证了类型安全 它是平台无关的，可移植性强 可用于基本数据类型 指针常量/常量指针 指针常量是指定义的指针只能在定义的时候初始化，之后不能改变其值。其格式为： [数据类型][*][const][指针常量名称] 例如：char const p1; int \\const p2;（顶层const） 常量指针的值不能改变，但是其指向的内容却可以改变。 常量指针是指指向常量的指针，因为常量指针指向的对象是常量，因此这个对象的值是不能够改变的。定义的格式如下： [数据类型][const][*][常量指针名称]; 例如，int const *p; const int *p; 需要注意的是，指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变型，它所指向的对象的值是不能通过常量指针来改变的。20. C++函数传递参数的方式有哪些 值传递 当进行值传递时，就是将实参的值复制到形参中，而形参和实参不是同一个存储单元，所以函数调用结束后，实参的值不会改变。 指针传递（实际上指针的值还是没有改变的，改变的只是指针中存放的地址所指向的变量，如果要改变指针的值，需要传递指针的引用或者指向指针的指针） 当进行指针传递时，形参是指针变量，实参是一个变量的地址，调用函数时，形参（指针变量）指向实参变量单元。这种方式还是“值传递”，只不过实参的值是变量的地址而已。而在函数中改变的不是实参的值，而是实参中存放的地址所指向的变量的值。 传引用 实参地址传递到形参，使形参的地址取实参的地址，从而使形参与实参共享同一单元的方式。21. 重载与覆盖有什么区别？ 22. 是否可以通过绝对内存地址进行参数赋值与函数调用 23. 默认构造函数是否可以调用单参数构造函数 默认构造函数不可以调用单参数的构造函数。 例如：class A { public: A() { A(0); print(); } A(int j):i(j) { cout 此时i的值是未定义的。以上代码希望默认构造函数调用带参数的构造函数，可是却未能实现。因为在默认构造函数内部调用带餐的构造函数属于用户的行为而非编译器行为，它只执行函数调用，而不会执行其后的初始化表达式。只有生成对象时，初始化表达式才会随相应的构造函数一起调用。 可以使用委托构造函数class A { public: A():A(0) { print(); } A(int j):i(j) { cout 　　 25. C语言中各种变量的默认初始值是什么？ 全局变量放在内存的全局数据区，由编译器建立，如果在定义的时候不做初始化，则系统将自动为其初始化，数值型为0，字符型为NULL，即0，指针数组也被赋值为NULL。静态变量的情况与全局变量类似。而非静态局部变量如果不显示初始化，那么其内容是不可预料的，将是随机数，会很危险。 28. 面向对象的基本特征： 封装是指将客观事物抽象成类，每个类有自己的数据和行为实现保护。 继承可以使用现有类的所有功能，而不需要重新编写原来的类，它的目的是为了进行代码复用和支持多态。 多态是指同一个实体同时具有多种形式，它主要体现在类的继承体系中，它是将父对象设置成为一个或更多的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 29. 复制构造函数与赋值运算符的区别是什么？ 主要有以下3个方面的不同： 复制构造函数生成新的类对象，而赋值运算符不能。 由于复制构造函数是直接构造一个新的类对象，所以在初始化这个对象之前就不用检验源对象是否和新建对象相同。而赋值运算符总则需要这个操作，另外赋值运算符中如果原来的对象中有内存分配，要先把内存释放掉。 当类中有指针类型的成员变量时，一定要重写复制构造函数和赋值构造函数，不能使用默认的。 30. 基类的构造函数/析构函数是否能被派生类继承 基类的构造函数/析构函数不能被派生类继承。 基类的构造函数不能被派生类继承，派生类中需要声明自己的构造函数。在设计派生类的构造函数时，不仅要考虑派生类所增加的数据成员初始化，也要考虑基类的数据成员的初始化。声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化，需要调用基类构造函数完成。 基类的析构函数也不能被派生类继承，派生类需要自行声明析构函数。声明方法与一般类的析构函数一样，不需要显式地调用基类的析构函数，系统会自动隐式调用。需要注意的是，析构函数的调用次序与构造函数相反。 31. 初始化列表和构造函数初始化的区别是什么？ 初始化列表的一般形式如下： Object::Object(int _x,int _y):x(_x),y(_y) {} 构造函数初始化一般通过构造函数实现，实现如下： Object::Object(int _x,int _y) { 　　x=_x; 　　y=_y; } 上面的构造函数使用初始化列表的会显式地初始化类的成员；而没有使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化。 初始化和赋值对内置类型的成员没有什么的的区别，在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的。对非内置类型成员变量，因为类类型的数据成员的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用一个赋值赋值操作符才能完成（如果并未提供，则使用编译器提供的默认成员赋值行为）。为了避免两次构造，推荐使用类构造函数初始化列表。 但有很多场合必须使用带有初始化列表的构造函数。例如，成员类型是没有默认构造函数的类，若没有提供显示初始化时，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试调用默认构造函数将会失败。再例如const成员或者引用类型的成员，因为const对象或引用类型只能初始化，不能对它们进行赋值。 32. 类的成员变量的初始化顺序 变量的初始化顺序： 基类的 静态变量或全局变量。 派生类的静态变量或全局变量 基类的成员变量 派生类的成员变量 构造的顺序： 虚基类的构造函数->一般基类构造函数的调用（根据声明的次序调用每一个基类的构造函数）->如果存在虚函数表，设定vptr的值->对构造函数初始列表中的其他成员进行构造->如果存在对象成员分别调用其构造函数进行构造->初始化列表中的成员按照其在类中的声明次序进行构造->执行构造函数体内的代码 34. 构造函数没有返回值，那么如何得知对象是否构造成功？ 这里的“构造”不是单指分配对象本身的内存，而是指建立对象时做的初始化（如打开文件、连接数据库） 因为构造函数没有返回值，所以通知对象的构造失败的唯一方法就是在构造函数中抛出异常。构造函数中抛出异常将导致对象的析构函数不被执行，但对象发生部分构造时，已经构造完毕的子对象将会逆序地被析构。 35. C++中的空类默认产生哪些成员函数 C++中空类默认会产生以下6个函数：* 默认构造函数 复制构造函数 析构函数 赋值运算符重载函数 取址运算符重载函数 const取址运算符重载函数等。class Empty { public: Empty();//默认构造函数 Empty(const Empty&);//复制构造函数 ~Empty(); //析构函数 Empyt& operator=(const Empty&); //赋值运算符 Empty* operator&(); //取址运算符 const Empty* operator&() const;//取址运算符const }; C++提供默认值参数的函数 注意： 如果一个函数中有过个默认值，则形参分布中，默认参数应从右至左逐渐定义。 在默认参数调用时，调用顺序为从左至右逐个调用 默认值可以是全局变量、全局常量，甚至可以是一个函数，默认值不能是局部变量 默认参数可将一系列简单的重载函数合成为一个36. 实现多态的基本原理 应在构造函数中实现虚函数表的创建和虚函数指针的初始化。根据构造函数的调用顺序，在构造子类对象时，先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承，它初始化父类对象的虚函数表的指针，该虚函数表指针指向父类的虚函数表。当执行子类的构造函数时，子类对象的虚函数表指针被初始化，指向自身的虚函数表。 编译器发现一个类中有虚函数，便会立即为此类生成虚函数表，虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个vptr指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行vptr与vtable的关联代码，将vptr指向对应的vtable，将类与此类的vtable联系起来，另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体类的this指针，这样依靠此this指针即可得到正确的vatble。这样才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。37. C++中的多态种类有哪几种？ C++中的多态包括参数多态、引用多态、过载多态和强制多态等。 参数多态是指采用参数化模板，通过给定不同的类型参数，使得一个结构有多种类型、模板。 引用多态是指同样的操作可以用于一个类型及其子类型。 过载多态是指同一个名字在不同的上下文中有不同的类型。 强制多态则是指把操作对象的类型强加以变换，以符合或操作符的要求。38. 什么函数不能声明为virtual 有5种情况： 只有类的成员函数才能说明为虚函数 静态成员不能为虚函数，因为调用静态成员函数不要实例，但调用虚函数需要从一个实例中指向虚函数表的指针以得到函数的地址，因此调用虚函数需要一个实例，两者互相矛盾。 内联函数不能为虚函数 构造函数不能为虚函数 析构函数可以为虚函数，而且通常声明为虚函数 构造函数不能是虚函数，是因为构造函数是在对象完全构造之前运行的，换句话说，运行构造函数前，对象还没有生成，更谈不上动态类型了。构造函数是初始化虚表指针，而虚函数放在虚表里面，当要调用虚函数的时候首先要知道虚表指针，这个就是矛盾的地方了，所以构造函数不可能是虚函数。一般上，构造函数是不能调用虚函数，但是在构造函数中还是可以调用虚函数，只是此时的虚函数不会表现动态类型，而只是静态类型。39. 是否可以把每个函数都声明为虚函数 虽然虚函数很有效，但是不能把每个函数都声明为虚函数。因为使用虚函数是要付出代价的。由于每个虚函数的对象在内存中都必须维护一个虚函数表指针，因此在使用虚函数时，尽管带来了方便，却会额外产生一个系统开销。40. C++如何阻止一个类被实例化 使用抽象类 将构造函数声明为private41. C++哪些函数只能使用成员初始化列表而不能使用赋值。 在C++赋值与初始化列表的情况不一样，只能用初始化列表而不能用赋值的情况一般有一下3种： 当类中含有const（常量）、reference（引用）成员变量时，只能初始化不能对他们进行赋值。常量不能被赋值，只能被初始化，所以必须在初始化列表中完成，C++的引用也一定要初始化，所以必须在初始化列表中完成。 基类的构造函数都需要初始化列表。构造函数的意思是先开辟空间然后为其赋值，只能算是赋值，不算初始化。 成员类型是没有默认构造函数的类。若没有提供显式初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。42. 虚函数 指向基类的指针在操作它的多态类对象时，会根据不同的类对象调用其相应的函数，这个函数就是虚函数。虚函数使用virtual修饰函数名。虚函数的作用是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数进行重新定义。在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型，以实现统一的接口。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。 在使用虚函数时要注意以下几方面： 只需要在声明函数的类体中使用关键字virtual将函数声明为虚函数，而定义函数时不需要使用关键字virtual。 当将基类中的某一成员函数声明为虚函数后，派生类中的同名函数自动成为虚函数。 如果声明了某个成员函数为虚函数，则在该类中不能再出现与这个成员函数同名并返回值、参数个数、类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种同名函数。 非类的成员函数不能定义为虚函数，全局函数以及类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以讲析构函数定义为虚函数。将基类的析构函数定义为虚函数后，当利用delete删除一个指向派生类定义的对象指针时，系统会调用相应的类的析构函数。而不将析构函数定义为虚函数时，只调用基类的析构函数。 普通派生类对象，先调用基类构造函数再调用派生类构造。 基类的析构函数应该定义为虚函数，这样可以在实现多态的时候不造成内存泄露。基类析构函数未声明virtual，基类指针指向派生类时，delete指针不调用派生类析构函数。有virtual，则先调用派生类析构函数再调用基类析构。 基类指针动态建立派生类对象，普通调用派生类构造函数 指针声明不调用构造函数。43. 写出float x 与“零值”比较的if语句 写出float x 与“零值”比较的if语句 请写出 float x 与“零值”比较的 if 语句： const float EPSINON = 0.00001; if ((x >= - EPSINON) && (x =”或“ 24. 什么是可重入函数？C语言如何写可重入函数 可重入函数是指能够被多个线程“同时”调用的函数，并且能保证函数结果正确性的函数。 在C语言中编写可重入函数时，尽量不要使用全局变量或静态变量，如果使用了全局变量或静态变量，就需要特别注意对这类变量访问的互斥。一般采用以下几种措施来保证函数的可重入性：信号量机制、关调度机制、关中断机制等方式。 biaozhunk 需要注意的是，不可调用不可重入函数，当调用了不可重入的函数时，会使该函数也变为不可重入的函数。一般驱动程序都是不可重入的函数，因此在编写驱动程序时一定要注意重入的问题。26. 编译和链接的区别 27. 编译型语言和解释性语言的区别 33. C++能设计实现一个不能被继承的类 C++不同于Java，Java中被final关键字修饰的类不能被继承。C++能实现不能继承的类，但是需要自己实现。 为了使类不被继承，最好的办法是使子类不能构造父类的部分，此时子类就无法实例化整个子类。在C++中，子类的构造函数会自动调用父类的构造函数，子类的析构函数也会自动调用父类的析构函数，所以只要把类的构造函数和析构函数都定义为private函数，那么当一个类试图从它那儿继承时，必然会由于试图调用构造函数、析构函数而导致编译错误，此时该类不能被继承。 可是这个类的构造函数和析构函数都是私有函数了，我们怎样才能得到该类的实例呢？这难不倒我们，我们可以通过定义静态来创建和释放类的实例。 基于这个思路，我们可以写出如下的代码： class FinalClass1 { public : static FinalClass1* GetInstance() { return new FinalClass1; } static void DeleteInstance( FinalClass1* pInstance) { delete pInstance; pInstance = 0; } private : FinalClass1() {} ~FinalClass1() {} }; //这个类在基本上就能实现不能继承的功能。但是每次如果你都用这样一个类的话，估计你到最后不是你的程序崩溃了，而是你自己崩溃的更早。 //因此，我们这样设计。 class CFinalClassMixin { friend class CParent; private: CFinalClassMixin(){} ~CFinalClassMixin(){} }; class CParent: public CFinalClassMixin { public: CParent(){} ~CParent(){} }; class CChild : public CParent { }; //但是发现没有用，想一想也是，CChild构造函数调用CParent的构造函数，而CParent的构造函数再调用CFinalClassMixin的构造函数，很显然是合法的。 //我估计你也想骂了，唧唧歪歪讲了这么就还是不行。 //但是请你想想，如果我是在CChild的构造函数直接调用CFinalClassMixin的构造函数，而CFinalClassMixin的构造函数是private，不能被调用，那我们岂不是达到了目的，但是我们如何才能在CChild中直接调用CFinalClassMixin的构造函数而不是通过CParent去调用了。 //给你一分钟去想想。。。。。。。。。。。。。。 //哈哈虚继承，虚继承刚好可以实现上述目的。 //因此： class CFinalClassMixin { friend class CParent; private: CFinalClassMixin(){} ~CFinalClassMixin(){} }; class CParent: virtual public CFinalClassMixin { public: CParent(){} ~CParent(){} }; "},"pythonNotes/python基础总结.html":{"url":"pythonNotes/python基础总结.html","title":"python基础总结","keywords":"","body":"Python 面试准备fasd 使用join(list)，拼接字符串 使用解压赋值取出list中的连续的一串 什么是元类: 在python中皆为对象，而元类即是用来创建类的”东西”。 类也是元类的实例。 而在python中，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类。 元类主要的用途是用来创建API,比如django的ORM。 re中search和match的区别: search和match都在re模块中. match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None。 search匹配整个字符串，直到找到一个匹配。 深浅拷贝的区别: 浅拷贝没有拷贝子对象，所以原对象发生改变，其子对象也发生了改变。 而深拷贝拷贝了子对象，原对象发生改变，其本身也不会改变。 Python 内存管理 python内部使用引用计数，来保持追踪内存中的对象 Python内部记录了对象有多少个引用，即引用计数 当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。 所有这些都是自动完成，不需要像C一样，人工干预，从而提高了程序员的效率和程序的健壮性。 filter 用于过滤与函数func()不匹配的值 shuffle # random模块中的shuffle(洗牌函数) import random list = [1, 2, 3, 4] random.shuffle(list) print(list) 装饰器 装饰器是一个函数，接收一个函数返回另一个函数。用法如下： from functools import wraps import time def recordtime(func): \"\"\" Decorator that reports the execution time. \"\"\" @wraps(func) def www(*args, **kwargs): start = time.time() re = func(*args, **kwargs) end = time.time() print(func.__name__, end - start) return re return www @recordtime def foo(n): sum = 1 for i in range(1, n): sum *= i foo(1000) 输入一个列表 >>> x=input() 1 2 3 4 >>> xlist=x.split(\" \") >>> print(xlist) ['1', '2', '3', '4'] >>> xlist = [int(xlist[i]) for i in range(len(xlist))] >>> print(xlist) [1, 2, 3, 4] "},"machineLearning/kNN.html":{"url":"machineLearning/kNN.html","title":"kNN","keywords":"","body":"kNN 算法 "},"machineLearning/L1-L2正则化.html":{"url":"machineLearning/L1-L2正则化.html","title":"L1-L2正则化","keywords":"","body":"L1, L2正则化 L2正则 L = Ein + λ∑Wj² s.t. ||W|| 当两个向量平行的时候最优值： -∇Ein + λW = 0 ∇Ein + λW = 0 Eog = Ein + λW²/2 (求导后，在0处取最优值) L1正则 L = Ein + λ∑|Wj| s.t. ∑|Wj| 解的稀疏性 L1更容易得到稀疏解. 因为L1的限定区域是包含凸点的，尖锐的 这些凸点更容易接近Ein函数的最优解的位置，这些点上的w很多为0 而L2是平滑的，与中心点等距 正则化参数λ 若λ很小（接近于零）相当于没有正则化项，对w没有惩罚，则容易过拟合。 λ↑ C↓， 限定区域较小，距离最优解较远，导致w普遍较小，容易欠拟合。 "},"machineLearning/":{"url":"machineLearning/","title":"README","keywords":"","body":"常见机器学习概括 kNN 决策树 Bayes Logistic Regression SVM Liner Regression Bagging Boosting Adaboost k-means 随机森林 "},"machineLearning/决策树.html":{"url":"machineLearning/决策树.html","title":"决策树","keywords":"","body":"决策树 选哪个特征 直观上，如果一个特征具有更好的分类能力，或者说，按照这一特征将训练数据集分割成子集，使得各个子集在当前条件下有最好的分类，那么就更应该选择这个特征。信息增益就能够很好地表示这一直观的准则。 什么是信息增益呢？在划分数据集之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。 香农熵 集合信息的度量方式称为香农熵或者简称为熵(entropy). 熵定义为信息的期望值。在信息论与概率统计中，熵是表示随机变量不确定性的度量。如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为 ： 计算所有类别所有可能值包含的信息期望值(数学期望) 期中n是分类的数目。熵越大，随机变量的不确定性就越大。 经验熵 当熵中的概率由数据估计(特别是最大似然估计)得到时，所对应的熵称为经验熵(empirical entropy)。 什么叫由数据估计？比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。 条件熵 条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条件熵(conditional entropy)H(Y|X)，定义为X给定条件下Y的条件概率分布的熵对X的数学期望： 同理，当条件熵中的概率由数据估计(特别是极大似然估计)得到时，所对应的条件熵称为条件经验熵. 举个例子 以贷款申请样本数据表为例进行说明。看下年龄这一列的数据，也就是特征A1，一共有三个类别，分别是：青年、中年和老年。我们只看年龄是青年的数据，年龄是青年的数据一共有5个，所以年龄是青年的数据在训练数据集出现的概率是十五分之五，也就是三分之一。同理，年龄是中年和老年的数据在训练数据集出现的概率也都是三分之一。现在我们只看年龄是青年的数据的最终得到贷款的概率为五分之二，因为在五个数据中，只有两个数据显示拿到了最终的贷款，同理，年龄是中年和老年的数据最终得到贷款的概率分别为五分之三、五分之四。所以计算年龄的信息增益，过程如下： 其他算法 构建决策树的算法有很多，比如C4.5、ID3和CART，这些算法在运行时并不总是在每次划分数据分组时都会消耗特征。由于特征数目并不是每次划分数据分组时都减少，因此这些算法在实际使用时可能引起一定的问题。 ID3算法 ID3算法的核心是在决策树各个结点上对应信息增益准则选择特征，递归地构建决策树。具体方法是：从根结点(root node)开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子节点；再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择为止。 决策树的一些缺点 决策树学习可能创建一个过于复杂的树，并不能很好的预测数据。也就是过拟合。修剪机制（现在不支持），设置一个叶子节点需要的最小样本数量，或者数的最大深度，可以避免过拟合。 决策树可能是不稳定的，因为即使非常小的变异，可能会产生一颗完全不同的树。这个问题通过decision trees with an ensemble来缓解。 贝叶斯 看下面这个blog 朴素贝叶斯 贝叶斯和朴素贝叶斯的概念是不同的，区别就在于“朴素”二字，朴素贝叶斯对条件个概率分布做了条件独立性的假设。 现在又来了第七个病人，是一个打喷嚏的建筑工人。请问他患上感冒的概率有多大？ 根据贝叶斯定理： 机器学习实战教程（四）：朴素贝叶斯基础篇之言论过滤器 可得： 机器学习实战教程（四）：朴素贝叶斯基础篇之言论过滤器 根据朴素贝叶斯条件独立性的假设可知，\"打喷嚏\"和\"建筑工人\"这两个特征是独立的，因此，上面的等式就变成了 机器学习实战教程（四）：朴素贝叶斯基础篇之言论过滤器 这里可以计算： 机器学习实战教程（四）：朴素贝叶斯基础篇之言论过滤器 因此，这个打喷嚏的建筑工人，有66%的概率是得了感冒。同理，可以计算这个病人患上过敏或脑震荡的概率。比较这几个概率，就可以知道他最可能得什么病。 这就是贝叶斯分类器的基本方法：在统计资料的基础上，依据某些特征，计算各个类别的概率，从而实现分类。 同样，在编程的时候，如果不需要求出所属类别的具体概率，P(打喷嚏) = 0.5和P(建筑工人) = 0.33的概率是可以不用求的。 概率也就是0了。显然，这样是不合理的，为了降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。这种做法就叫做拉普拉斯平滑(Laplace Smoothing)又被称为加1平滑，是比较常用的平滑方法，它就是为了解决0概率问题。 另外一个遇到的问题就是下溢出，这是由于太多很小的数相乘造成的。学过数学的人都知道，两个小数相乘，越乘越小，这样就造成了下溢出。在程序中，在相应小数位置进行四舍五入，计算结果可能就变成0了。为了解决这个问题，对乘积结果取自然对数。通过求对数可以避免下溢出或者浮点数舍入导致的错误。同时，采用自然对数进行处理不会有任何损失。下图给出函数f(x)和ln(f(x))的曲线。 "},"machineLearning/随机森林RF.html":{"url":"machineLearning/随机森林RF.html","title":"随机森林RF","keywords":"","body":"随机森林算法学习 定义： 即通过对数据集的采样生成多个不同的数据集，并在每一个数据集上训练出一颗分类树，最终结合每一颗分类树的预测结果作为随机森林的预测结果 要学随机森林，首先先简单介绍一下集成学习方法和决策树算法。下文仅对该两种方法做简单介绍（具体学习推荐看统计学习方法的第5章和第8章）。 Bagging和Boosting的概念与区别 该部分主要学习自：http://www.cnblogs.com/liuwu265/p/4690486.html 随机森林属于集成学习（Ensemble Learning）中的bagging算法。在集成学习中，主要分为bagging算法和boosting算法。我们先看看这两种方法的特点和区别。 Bagging（套袋法） bagging的算法过程如下： 从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复） 对于k个训练集，我们训练k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等） 对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同） Boosting（提升法） boosting的算法过程如下： 对于训练集中的每个样本建立权值wi，表示对每个样本的关注度。当某个样本被误分类的概率很高时，需要加大对该样本的权值。 进行迭代的过程中，每一步迭代都是一个弱分类器。我们需要用某种策略将其组合，作为最终模型。（例如AdaBoost给每个弱分类器一个权值，将其线性组合最为最终分类器。误差越小的弱分类器，权值越大） Bagging，Boosting的主要区别 样本选择上：Bagging采用的是Bootstrap随机有放回抽样；而Boosting每一轮的训练集是不变的，改变的只是每一个样本的权重。 样本权重：Bagging使用的是均匀取样，每个样本权重相等；Boosting根据错误率调整样本权重，错误率越大的样本权重越大。 预测函数：Bagging所有的预测函数的权重相等；Boosting中误差越小的预测函数其权重越大。 并行计算：Bagging各个预测函数可以并行生成；Boosting各个预测函数必须按顺序迭代生成。 下面是将决策树与这些算法框架进行结合所得到的新的算法： Bagging + 决策树 = 随机森林 AdaBoost + 决策树 = 提升树 Gradient Boosting + 决策树 = GBDT 决策树 常用的决策树算法有ID3，C4.5，CART三种。3种算法的模型构建思想都十分类似，只是采用了不同的指标。决策树模型的构建过程大致如下： ID3，C4.5决策树的生成 输入：训练集D，特征集A，阈值eps 输出：决策树T 若D中所有样本属于同一类Ck，则T为单节点树，将类Ck作为该结点的类标记，返回T 若A为空集，即没有特征作为划分依据，则T为单节点树，并将D中实例数最大的类Ck作为该结点的类标记，返回T 否则，计算A中各特征对D的信息增益(ID3)/信息增益比(C4.5)，选择信息增益最大的特征Ag 若Ag的信息增益（比）小于阈值eps，则置T为单节点树，并将D中实例数最大的类Ck作为该结点的类标记，返回T 否则，依照特征Ag将D划分为若干非空子集Di，将Di中实例数最大的类作为标记，构建子节点，由结点及其子节点构成树T，返回T 对第i个子节点，以Di为训练集，以A-{Ag}为特征集，递归地调用1~5，得到子树Ti，返回Ti CART决策树的生成 这里只简单介绍下CART与ID3和C4.5的区别。 CART树是二叉树，而ID3和C4.5可以是多叉树 CART在生成子树时，是选择一个特征一个取值作为切分点，生成两个子树 选择特征和切分点的依据是基尼指数，选择基尼指数最小的特征及切分点生成子树 决策树的剪枝 决策树的剪枝主要是为了预防过拟合，过程就不详细介绍了。 主要思路是从叶节点向上回溯，尝试对某个节点进行剪枝，比较剪枝前后的决策树的损失函数值。最后我们通过动态规划（树形dp，acmer应该懂）就可以得到全局最优的剪枝方案。 随机森林（Random Forests） 随机森林是一种重要的基于Bagging的集成学习方法，可以用来做分类、回归等问题。 随机森林有许多优点： 具有极高的准确率 随机性的引入，使得随机森林不容易过拟合 随机性的引入，使得随机森林有很好的抗噪声能力 能处理很高维度的数据，并且不用做特征选择 既能处理离散型数据，也能处理连续型数据，数据集无需规范化 训练速度快，可以得到变量重要性排序 容易实现并行化 随机森林的缺点： 当随机森林中的决策树个数很多时，训练时需要的空间和时间会较大 随机森林模型还有许多不好解释的地方，有点算个黑盒模型 与上面介绍的Bagging过程相似，随机森林的构建过程大致如下： 从原始训练集中使用Bootstraping方法随机有放回采样选出m个样本，共进行n_tree次采样，生成n_tree个训练集 对于n_tree个训练集，我们分别训练n_tree个决策树模型 对于单个决策树模型，假设训练样本特征的个数为n，那么每次分裂时根据信息增益/信息增益比/基尼指数选择最好的特征进行分裂 每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类。在决策树的分裂过程中不需要剪枝 将生成的多棵决策树组成随机森林。对于分类问题，按多棵树分类器投票决定最终分类结果；对于回归问题，由多棵树预测值的均值决定最终预测结果 "}}