# 聊天软件uTim
我负责模块的相关原理解析：
多线程实现：
1. 服务器在接收到客户端的连接请求时，为该客户端分配一个tcpsocket与之对接，并新建一个线程，同时将该tcpsocket作为参数初始化该线程，使该线程与客户端交互。
2. 同时启动该线程。该线程启动后会建立监听该tcpsocket信号的连接槽函数。当有数据写入该socket的时候，线程会读取全部内容，并转发给主线程进行分析。
3. 当有信息需要写入时，也是通过对应的线程写入连接好的tcpsocket中。
4. 从而通过多线程实现多客户端的同时监听。

私聊功能：
1. 用户选择用户编辑好信息后点击发送，会触发on_pushButton_2_clicked()函数，该函数首先获取当前对象名称，若不是“讨论组”，则通过tcp协议向对应的服务器的某一个线程发送报文：SiLiao#当前选择的用户#&lt;消息内容&gt;。同时将消息追加的消息框中。清空聊天输入的内容。
2. 服务器对应线程的tcpsocket有数据需要读出时，会读取该数据，并将消息所有内容传递给主线程，主线程从这个线程中可以获取到发送方的用户名，加入到这条消息中，并遍历所有线程，找到接收用户对应的线程转发该信息。
3. 该用户收到后进行解析，显示在发送方对应的聊天记录中，并跳转到该用户的聊天窗口。

发文件功能涉及到的函数解析：
(只详细解释客户端发送服务器接收的情况，反向的操作大致一致，不再赘述。)
Client=>	On_sendFilePushButton_clicked():
1. 通过getOpenFileName()函数显示一个选择发送文件的窗口，选择好文件后确认，返回值是该文件的详细路径。通过QFileInfo的内置函数size（）获得该文件的大小信息，通过除以片数大小可以得到总片数。
2. 然后将文件路径通过“/”分割，得到文件名。接着向服务器对应线程的udpsocket发送信息“start#文件名”。

Server=>	receive():
服务器接收后循环将udpsocket中的数据全部读出，并进行解析。
1. 若数据前端字符串是“start#文件名”，则通过#分割后，将文件名取出，并通过全局变量file打开该文件，并清空之前的内容。如果成功打开，则向客户端的udpsocket回复一个“6”。
2. 若数据前端的字符串是“end#”，则关闭文件，并向主线程发送信号RecvEnd（），主线程接收后将更新后的服务器文件列表发送给所有用户。
3. 其他情况，则必定是文件数据信息，则将读取到的数据全部写入文件file。并向客户端的udpsocket回复一个“6”。

Client=>	SendData(): (当客户端的udpsocket读取到的消息为“6”时，执行此函数。)
1. 首先判读文件file是否读取完毕，若未结束，则读取一片的大小，并将这些数据通过服务器对应线程的udpsocket全部发送。同时更新进度条。
2. 若文件结束，则关闭文件file。并向服务器对应线程的udpsocket发送信息“end#文件名”。(服务器的receive函数会解析该信息，如上述所示。)

群聊功能涉及到的函数解析：
Client=>	on_pushButton_2_clicked(): (当用户点击发送按钮时执行)
1. 首先判断文件是否连接成功，若成功则继续。
2. 判断当前聊天对象是否是 “讨论组”。
3. 若是讨论组，则通过建立好的tcpsocket写入信息“QunFa#&lt;消息编辑区域详细内容&gt;”。
4. 同时在消息显示区域追加信息“【Me】：&lt;消息编辑区域详细内容&gt;”。并保存到讨论组对应的聊天记录中。最后清空编辑区域的内容。
5. 服务器对应线程接收后将信息追加上用户名后传递给主线程，主线程通过多个线程将其转发给其他用户。
6. 其他用户解析后显示在群消息中。

Server=>	analyzeData(): （服务器的tcpsocket有数据的时候执行）
服务器tcpsocket接收到信息后读取并解析，若开头的字符串是“QunFa#”，则通过#分割后取出该消息，并通过发送端的端口获得该用户的名字，同时转发给所有其他用户。

Client=>	analyzeData（）：(客户端的tcpsocket有数据的时候执行)
客户端的接收数据后读出，通过#分割出用户名和信息。同时显示在消息显示区域。
